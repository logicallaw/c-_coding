/*
새로운 개념
1.&:Lvalue만 가능
int a = 5;
int& r1 = a;(가능)
int& r2 = 5;(error)
2.const &:Lvalue와 Rvalue가능
-다만, const로 인해 그 참조자는
동일한 이름이지만, 값 변경 불가. 원본은 값 변경 가능함
3.&&:Rvalue만 가능(Lvalue는 오류남)
4.&는 데이터타입 정의와 주소의 의미 두가지가 있다.
&는 주소다 또는 참조는 주소다는 틀린말.
5.*는 포인터타입 정의와 역참조 연산 의미 두가지가 있다.
6.포인터는 주소를 가지고 있는 변수이다. 그 주소를 참조해 값을 바꿀려면
역참조 연산을 해야한다. 역참조 연산은 *를 통해 접근 가능해 값을 바꿀 수 있다.
7.포인터 const
const int&:역참조 연산 불가능, 하지만 주소 변경 가능
int& const:역참조 연산 가능, 하지만 주소 변경 불가능
const int& const:역참조와 주소변경 둘다 불가능
8.가리키는 변수가 const이면 포인터는 const만 가능
(왜냐면, 역참조로 바꿀 수 있을 수 있기 때문에)
7번과 같은 내용.
9.이중포인터는 포인터의 주소를 받는다. 일반 변수의 주소를 받으면 에러가 난다.
포인터를 참조하는게 이중포인터이다.
포인터 참조는 오직 이중포인터만 가능하다.
10.static_cast<data-type*>(포인터)
:void형 포인터의 형변환은 static_cast 사용하는데 <자료형*>으로 바꾸어야한다.
11.string의 크기는 length()으로 구한다. (실습문제에 등장)
12.string은 각각 char이다.
*(s.begin() + i)로 각 char의 char값을 구할 수 있다.
아스키코드가 등장하고
숫자면 '0'을 빼서 구해야한다.

*/

/*
실수포인트
1.포인터가 매개변수일 때, 인수로 주소를 전달해야함. &으로 주소 전달 해야한다.
실수 포인트
2.범위기반 for문 사용시 cin으로 배열의 요소를 입력하는경우
&참조자를 반드시 사용해야한다!
(배열의 요소:built-in-array/array/vector 모두 &참조자로 받아야 값이 바뀐다)

너무 실수하니 반드시 잡고 가자!!!

2.swap(포인터로 객체 받기)
swap(Student* s1, Student* s2) {
	Student temp = *s1;
	*s1 = *s2 //원래는 *s1{ *s2 }; 객체 저장 원리는 복사 생성자를 이용하는 거임.
	*s2 = temp; //원래는 *s2{ temp };
}
swap할 때 마지막에 s1이 아니라 temp인거 너무 많이 실수한다. 주의하자
*/

/*
아에 몰라서 답안 본 문제
9-9.cpp
*/

/*
다시볼 문제
9-9.cpp:string::length()와 string::begin()함수가 새로움
*/

/*
실습문제 자주나오는 코드 정리
1.bubble_sort()
기본적으로 작은거에서 큰거로 정렬 ([j] > [j+1])
부등호 반대로 하면 큰거에서 작은거로 정렬([j] < [j+1])

*/