/*
새로운 개념
1.범위기반 for문에서 배열요소 정의시
const 자료형&으로 선언 가능함.
const를 붙일 수 있다.
(ex)const Circle&t

2.array 클래스 기본 문법
array<자료형, 크기> 배열명{ 초기화 };

3.size_t 자료형은 unsigned __int64(64비트의 부호없는 정수형)와 같다.
보통, size_t 자료형은 for문의 제어변수 선언시 사용한다.

4. .size() 멤버함수는 array 클래스의 멤버함수로서
해당 배열의 길이를 size_t형으로 리턴한다.

5.array객체 범위기반 for문 순회할때
array가 아니라 해당 배열의 자료형을 조건식에 적어야한다.
(ex)
for (array e : arr)가 아니라 for (int e : arr)로 해야 에러가 안난다.

6.array<자료형, 배열크기>에서 배열크기 없으면 컴파일 에러난다!!
7.array는 한 번 초기화되고 이후에 전체 배열에 대한 재 할당 가능하다!!
(ex)
array<int, 5> arr{ 0 }; //0,0,0,0,0
arr = {1,2,3,4,5}; //가능!! 에러 안발생함
arr = {1,2}; //가능!! 1,2,0,0,0으로 할당됨.

8.array의 배열 요소의 값은 .at(인덱스)로 가져올 수 있다.

9.static array<int,5> arr; 해도 쓰레기값이 출력되는게 아니라
static이 있는 array는 초기화안해도 기본적으로 0으로 초기화된다.

10.array는 배열 속성있지만 객체이다.
11.함수의 인수로 array받을 때 기본적으로 배열 크기도 있기 때문에 따로 안받아도됨.
12.함수의 인수로 array받고도 범위기반 for문 사용 가능하다.(자체적인 배열 크기 존재하기 때문에)
-pass-by-value도 가능하지만, pass-by-reference를 사용한다.
pass-by-value는 &참조자 사용하지 않고,
pass-by-reference는 &를 사용한다.

내장배열과 차이점은 내장배열은 인수로 전달할 때 굳이 참조자 사용안해도
pass-by-reference이고
array 배열은 인수로 전달할 때, pass-by-reference를 하려면 &참조자를 사용해야한다.

13.2차원 배열
int ary[행][열]

*/

/*
부족한 개념
1.배열을 한번 초기화하면, 이후에 다시 전체 배열을 재 할당할 수는 없다.
메모리 공간의 크기를 변경할 수 없기 때문이다.
개별 공간은 재할당 가능하다.
(ex)
int a[5] = { 0 };
a = { 1, 2, 3, 4, 5}; //는 에러 발생함.

2.배열 선언만하고 초기화 안하면 쓰레기값 발생함(컴파일 에러는 안남)
(ex)
int a[5];
for (const int& b : a)
	cout << b << " "; //쓰레기값 출력됨.
cout << endl;

3.배열명[배열크기] = { 0 };은 모두 0으로 초기화되지만
{ 1 };은 0번째 요소가 1이고 나머지 0으로 초기화되니
주의하자!!

4.array<> 배열명{};은 0으로 자동초기화 된것이다.
*/

/*
다시 볼 문제
8-1.cpp(lab11 prmg 1)
:bubble 정렬 코드 복습하기!!

*/