/*
개념정리

클래스와 객체는 데이터타입과 인스턴스와 관계와 유사하다(비유된다).
인스턴스는 값만 구성되지만, 객체는 값과 기능을 구성한다.
클래스를 만드는 것은 사용자 정의의 새로운 데이터타입을 생성하는 것이다.
기본 데이터타입은 하나의 값만 구성하지만, 클래스는 여러 값과 관련 기능을 추가로 포함한다.
클래스는 실체가 없고 객체는 데이터를 가진 실체가 있는 존재이다.

멤버변수(=멤버데이터, 데이터멤버, 필드, 속성)
-주로 private속성에서 선언한다.
멤버함수(=메소드, 행위)
-주로 public속성에서 선언한다.
-멤버변수에 직접 접근이 가능해, 객체와 멤버변수의 다리역할을 수행한다.
-멤버함수는 주로 클래스 외부에서 정의한다.

클래스 정의
-클래스 정의란, 새로운 데이터 타입을 작성하는 것이다.
-헤더, 본문, 세미콜론(;)으로 구성된다.

멤버변수 선언
-객체의 데이터를 저장하기 위해 선언한다.
-기본타입/사용자 정의 타입(클래스 등) 모두 사용 가능하다.

멤버함수 선언
-클래스 내부에서 멤버함수의 프로토타입만 보통 선언한다.
-멤버함수 정의는 클래스 외부에서 정의한다.

상수 멤버함수 선언
-클래스 내부에서 const를 사용하여 선언된다. 형태는 리턴타입 멤버함수명(매개변수) const {블록} 순이다.
-const는 클래스 멤버변수의 값을 함수 내부에서 변경을 허용하지 않는다.
-단, 멤버함수 내에서 선언된 지역변수의 값의 변경은 허용한다.

객체의 인스턴스화:data-type 객체명
-기존 데이터타입을 가지고 변수를 만드는 과정과 동일하다.

멤버 접근 연산자
-'.(dot)'연산자를 사용하여 특정 객체의 멤버함수를 호출한다.
-함수를 호출한 객체의 데이터를 사용하여 멤버함수가 실행된다.

접근제한자
-모든 멤버의 기본 접근 권한은 private이다.
-private속성:클래스 외부에서 직접 접근 안돼서 public 멤버함수를 통해 간접 접근한다.

setter/getter
-설정자(setter):클래스 외부에서 private 멤버변수의 값 설정을 위해 사용한다.
-접근자(getter):클래스 외부에서 private 데이터멤버의 값을 얻기 위해 사용한다.
사용목적
-클래스 외부에서 데이터를 안전하게 접근하는 법 제공
-객체지향언어에서는 데이터는 보호되어야하고, 외부에서 데이터 직접접근을 기본적으로 차단한다.
-public 데이터멤버를 사용하는 것은 효율적으로 보일지 몰라도 더 큰 문제가 발생가능하다.

생성자
-객체가 생성될때(선언) 자동으로 호출되는 멤버함수이다.
-멤버함수와 다르게 리턴 개념이 없다.

기본생성자
-객체 생성시 매개변수가 하나도 없으면 실행되는 생성자이다.
-매개변수 없는 객체 생성시 초기화 방법은 데이터타입 객체명; 또는 데이터타입 객체명{};이다.
이때, 데이터타입 객체명();은 함수의 프로토타입으로 인식하므로 아니된다.
-객체 생성은 곧 생성자를 호출하는 것이고,
생성자 호출은 객체를 생성하는 것이므로,
클래스에 명시적으로 정의된 생성자가 하나도 없으면 기본 생성자를 자동으로 컴파일러가 추가한다는게 특징이다.(시텐틱)
(다만, 기본생성자 외의 생성자가 정의되어 있으면 객체 생성시 기본생성자로 호출하면 에러가 발생한다.)

매개변수가 있는 생성자(매개변수 생성자)
-매개변수생성자는 함수처럼 동작한다.

복사생성자
-어느 한 객체를 다른 객체로 복사하는 과정에서 사용되는 생성자이다.
-반드시, 참조타입으로 만들어야한다.
-const class-type& 으로 사용해야한다.
-이때, const는 없어도 되지만, 원치않는 결과가 출력될 수 있어 보통은 복사생성자 선언시 const를 사용한다.
-참조타입은 없으면 무한로프 걸려서 참조가 반드시 있어야한다.
-복사생성자는 없으면 필요시 기본적으로 컴파일러가 기본형태는 만들어준다.

member initializer list
-생성자() : 멤버변수1{초깃값 or 변수}, 멤버변수2{...},... {}
-하는이유:const 멤버변수 초기화시 유용하다.
-멤버이니셜라이져리스트는 객체 생성되는 과정에서 실행돼서 멤버변수 생성과정에 실행된다.
그래서 private속성의 const멤버변수를 초기화가 가능해진다.
-body는 객체생성 후 실행된다.(이는 실행시간이 달라서 가능한 이야기이다.)

소멸자
-객체가 소멸 과정에서 자동으로 호출되는 멤버함수이다.
-클래스는 한개의 소멸자만 갖는다.
-리턴개념이 없고 동일한 클래스명칭에 ~만 붙인다.
-대부분 경우 자원을 반환하는 코드를 소멸자에 작성한다.

synthetic member function
기본적으로 객체 선언시 필요에 따라 클래스 내부에 해당 생성자가 존재하지 않으면 
컴파일러가 아래 세가지는 해준다.
-기본생성자(클래스 내부에 생성자가 하나라도 없으면 컴파일러가 만들어준다)
-복사생성자(기본적인 형태로 만들어준다)
-소멸자(없으면 기본적으로 해주어서 현재로서는 소멸자 선언 생략해도 상관없다)
-생성자=default;는 컴파일러가 만들어주는데로 사용할 때 사용한다.
사용하는 이유는 가독성 때문에 필요하지 않은 생성자라도 default를 사용한다.
-생성자=delete;는 사용하지 않겠다고 알려주는 역할이며, 컴파일러는 해당 delete된 생성자를
자동으로 생성하지 않는다. 
예전같으면 private에 생성자를 임의로 넣어서 방지했지만, c++문법 발전으로 delete를 사용한다.
-소멸자 delete하면 객체 생성 불가능하다!!!!!!
소멸자도 반드시 필요하다.

기본적으로 생성자함수와 멤버함수 형태는 비슷하다.
생성자는 리턴이 없고 멤버 초기화 리스트를 사용할 수 있다.
다만, 함수는 리턴이 있는게 특징이고 const를 사용할 수 있다.
생성자와 멤버함수 공통점은 class-type scope::name으로 호출하는게 특징이다.
*/


/*
주의사항
1.int/int-->int라서 소수점 원한다면 static_cast<int>()/int로 해야 소수점 출력됨!!!!(7-4.cpp참고) !!!!!!!(실수포인트)
*/

/*
새로운 개념
클래스타입 멤버함수(객체) const;

호출
class-type name = obj1.name(obj2);
선언
class-type name(const class-type& obj) const;
정의
class-type class-type::name(const class-type& obj) const {
	int x = _x + obj._x;
	...
}

*/
/*
실습 문제 다시볼 만한 문항
7-4.cpp:static_cast<double>(int type) / (int type)
7-9.cpp:class-type name(const class-type& obj) const; (멤버함수인데 리턴타입이 객체)
7-10.cpp:생성자 매개변수 선언에서
객체를 받고 그 객체의 default를 설정해주고 있는 상황
Line(Point p1 = Point{ 0, 0 }, Point p2 = Point{ 0 , 0 });
Line(class-type obj1 = class-type{ default1, default2 }, ... );


좋은 문제
7-2-1
7-9, 7-10, 7-11
*/

